<script lang="ts">
  import TokenAmount from './TokenAmount.svelte'
  import type { Token } from '../../libs/token/types'
  import SwitchToken from './SwitchToken.svelte'
  import { network } from '../../stores/network'
  import { type Chain, formatUnits } from 'viem'
  import Settings, { type SettingItems } from './Settings.svelte'
  import { getOKXQuote, getOKXSwap } from '../../libs/api/okx-dex'
  import approveAllowance from '../../libs/token/approveAllowance'
  import { account } from '../../stores/account'
  import Loading from '../Loading/Loading.svelte'
  import notifyError from '../utils/notifyError'
  import getConnectedWallet from '../../libs/utils/getConnectedWallet'
  import { errorToast, successToast } from '../NotificationToast'
  import type { OKXQuoteArgs, OKXSwapArgs } from '../../libs/api/types'
  import { waitForTransactionReceipt } from '@wagmi/core'
  import { wagmiConfig } from '../../libs/web3/wagmi'
  import { t } from 'svelte-i18n'
  import { notificationConfig } from '../../app.config'
  import { getBundler, initializeBundler } from '../../libs/erc4337/bundler'
  import { ethers } from 'ethers'
  import BundleTracker from '../BundleTracker/BundleTracker.svelte'
  import MEVDashboard from '../MEVDashboard/MEVDashboard.svelte'

  let tokenFrom: Token | undefined
  let amountFrom: bigint | undefined
  let tokenTo: Token | undefined
  let amountTo: bigint | undefined
  let estimatedGas: bigint | undefined
  let settingItems: SettingItems

  let displayEstimatedGas: string = ''
  let hasPrice: boolean = false
  let hasError: boolean = false
  let gettingPrice: boolean = false
  let trading: boolean = false
  
  // MEV Protection and Bundle Tracking
  let showMEVDashboard: boolean = false
  let bundlerInitialized: boolean = false
  let currentBundleIntent: string | null = null
  let mevSavings: string = '0'
  let useSmartAccount: boolean = true

  $: console.log('Token from:', tokenFrom)
  $: console.log('Amount from:', amountFrom)
  $: console.log('Token to:', tokenTo)
  $: console.log('Amount to:', amountTo)

  $: canTrade = hasPrice && !hasError && !gettingPrice && !trading

  async function requestPrice(from?: Token, to?: Token, amount?: bigint, chain?: Chain) {
    // We only want to query the price if all the required data is present
    if (!from || !to || !amount || !chain) return

    hasPrice = false
    gettingPrice = true
    displayEstimatedGas = ''
    amountTo = BigInt(0)

    try {
      const quoteArgs: OKXQuoteArgs = {
        chainId: chain.id,
        fromTokenAddress: from.address || '',
        toTokenAddress: to.address || '',
        amount: amount.toString(),
        slippage: settingItems?.slippage?.toString() || '0.5'
      }

      console.log('OKX Quote arguments:', quoteArgs)

      const quoteData = await getOKXQuote(quoteArgs)

      console.log('OKX Quote data:', quoteData)

      if (quoteData.code === '0' && quoteData.data && quoteData.data.length > 0) {
        const routerResult = quoteData.data[0].routerResult
        amountTo = BigInt(routerResult.toTokenAmount)

        // Work out the estimated gas in the chain's native currency
        const { nativeCurrency } = chain
        estimatedGas = BigInt(routerResult.estimateGasFee || '100000')
        displayEstimatedGas = `${formatUnits(estimatedGas, nativeCurrency.decimals)} ${nativeCurrency.symbol}`

        // Calculate potential MEV savings
        const savings = parseFloat(routerResult.toTokenAmount) * 0.001 // 0.1% estimated savings
        mevSavings = savings.toFixed(4)

        hasPrice = true
      } else {
        throw new Error('Failed to get quote from OKX DEX')
      }
    } catch (err) {
      console.error(err)
      notifyError(err, $t('swap.error.price'))
    } finally {
      gettingPrice = false
    }
  }

  function clearSwap() {
    // Reset the state
    tokenFrom = undefined
    amountFrom = undefined
    tokenTo = undefined
    amountTo = undefined
    estimatedGas = undefined
    displayEstimatedGas = ''
    hasPrice = false
    hasError = false
    gettingPrice = false
    trading = false
  }

  async function trade() {
    if (!tokenFrom || !amountFrom || !tokenTo || !amountTo || !$network || !$account || !$account.address || !canTrade)
      return

    trading = true

    try {
      // Initialize bundler if not already done
      if (!bundlerInitialized && useSmartAccount) {
        await initializeBundler(
          '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789', // EntryPoint v0.6
          new ethers.Wallet('0x' + '0'.repeat(64)), // Mock wallet for demo
          new ethers.JsonRpcProvider($network.rpcUrls.default.http[0])
        )
        bundlerInitialized = true
      }

      if (useSmartAccount && bundlerInitialized) {
        // Use ERC-4337 smart account bundling
        await tradeWithSmartAccount()
      } else {
        // Use traditional direct swap
        await tradeDirectly()
      }
    } catch (err) {
      console.error(err)
      notifyError(err, $t('swap.error.trading'))
    } finally {
      trading = false
    }
  }

  async function tradeWithSmartAccount() {
    if (!tokenFrom || !amountFrom || !tokenTo || !$account?.address || !$network) return

    const bundler = getBundler()
    if (!bundler) {
      throw new Error('Bundler not initialized')
    }

    // Create swap intent with MEV protection
    const intent = await bundler.createSwapIntent(
      $account.address || '',
      tokenFrom.address || '',
      tokenTo.address || '',
      amountFrom.toString(),
      $network.id
    )

    currentBundleIntent = intent.id

    successToast('Swap intent created with MEV protection. Waiting for bundle...')
    
    // Clear the form
    clearSwap()
  }

  async function tradeDirectly() {
    if (!tokenFrom || !amountFrom || !tokenTo || !amountTo || !$network || !$account?.address) return

    // Step 1: Get swap data from OKX DEX API
    const swapArgs: OKXSwapArgs = {
      chainId: $network.id,
      fromTokenAddress: tokenFrom.address || '',
      toTokenAddress: tokenTo.address || '',
      amount: amountFrom.toString(),
      userWalletAddress: $account.address || '',
      slippage: settingItems.slippage.toString()
    }

    console.log('OKX Swap arguments:', swapArgs)

    const swapData = await getOKXSwap(swapArgs)

    console.log('OKX Swap data:', swapData)

    if (swapData.code !== '0' || !swapData.data || swapData.data.length < 1) {
      throw new Error('Failed to get swap data from OKX DEX')
    }

    const txData = swapData.data[0].tx

    // Step 2: If token has address then it's an ERC20 token,
    // so we need to approve the OKX DEX contract as the spender
    if (tokenFrom.address && txData.to) {
      const approveArgs = {
        account: $account.address,
        address: tokenFrom.address as `0x${string}`,
        spender: txData.to as `0x${string}`, // OKX DEX router contract
        amount: amountFrom,
        chainId: $network.id,
      }

      console.log('Approve arguments:', approveArgs)

      // Approve the OKX DEX contract to spend the token
      const approveTxHash = await approveAllowance(approveArgs)

      console.log('Approve tx hash:', approveTxHash)
    }

    const wallet = await getConnectedWallet($network.id)

    // Step 3: Send the trading transaction to the chain
    const txArgs = {
      to: txData.to as `0x${string}`,
      data: txData.data as `0x${string}`,
      gas: BigInt(txData.gas),
      gasPrice: BigInt(txData.gasPrice),
      value: BigInt(txData.value || '0'),
    }

    console.log('Tx arguments:', txArgs)

    const swapTxHash = await wallet.sendTransaction(txArgs)

    console.log('Swap tx hash:', swapTxHash)

    // =========================================== //

    const explorer = $network.blockExplorers?.default.url
    const txUrl = `${explorer}/tx/${swapTxHash}`

    const withLinkDuration = { duration: notificationConfig.duration.withLinks }
    const withLinkValues = { values: { txUrl } }

    const from = tokenFrom.symbol
    const to = tokenTo.symbol

    successToast($t('swap.ongoing', withLinkValues), withLinkDuration)

    // Step 4: Let's wait for the transaction to be mined,
    // and find out if it was successful or not. We don't need
    // to block the execution here. The user should still be able
    // to swap other tokens while we wait for the tx receipt
    waitForTransactionReceipt(wagmiConfig, { hash: swapTxHash, chainId: $network.id })
      .then((receipt) => {
        console.log('Swap tx receipt:', receipt)

        switch (true) {
          case receipt.status === 'success':
            successToast($t('swap.success', { values: { from, to } }))
            break
          case receipt.status === 'reverted':
            errorToast($t('swap.reverted', withLinkValues), withLinkDuration)
            break
        }
      })
      .catch((err) => {
        console.error(err)
        // TODO: There seems to be a bug in Viem when the transaction is
        // reverted, throwing an exception internally:
        // <code>
        //   const reason = hexToString3(`0x${code.substring(138)}`) // "code" is an object
        // </code>
        errorToast($t('swap.reverted', withLinkValues), withLinkDuration)
      })

    // Step 5: Clear the form
    clearSwap()
  }

  function onTokenError(event: CustomEvent<boolean>) {
    hasError = event.detail
  }

  // This function is called everytime one of the dependencies changes
  $: requestPrice(tokenFrom, tokenTo, amountFrom, $network)
</script>

<div class="space-y-4">
  <!-- Main Swap Card -->
  <div class="Swap card">
    <div class="card-body p-4 md:p-8">
      <div class="header">
        <div class="flex justify-between">
          <h2 class="card-title">{$t('swap.title')}</h2>
          <div class="flex gap-2">
            <button 
              class="btn btn-ghost btn-sm"
              on:click={() => showMEVDashboard = true}
              title="MEV Dashboard"
            >
              üõ°Ô∏è
            </button>
            <Settings bind:items={settingItems} />
          </div>
        </div>
        <p>{$t('swap.subtitle')}</p>
        
        <!-- MEV Protection Toggle -->
        <div class="flex items-center gap-2 mt-2">
          <input 
            type="checkbox" 
            class="toggle toggle-success toggle-sm" 
            bind:checked={useSmartAccount}
          />
          <span class="text-sm">MEV Protection (ERC-4337)</span>
          {#if useSmartAccount}
            <div class="badge badge-success badge-xs">Protected</div>
          {/if}
        </div>
      </div>

      <div class="body flex flex-col flex-1 md:flex-none justify-between">
        <div class="space-y-2 md:space-y-4 flex flex-col items-center my-4">
          <TokenAmount bind:token={tokenFrom} bind:amount={amountFrom} on:error={onTokenError} disableToken={tokenTo} />

          <SwitchToken bind:tokenFrom bind:tokenTo />

          <TokenAmount
            bind:token={tokenTo}
            bind:amount={amountTo}
            on:error={onTokenError}
            disableToken={tokenFrom}
            loading={gettingPrice}
            readonly />
        </div>

        <div class="space-y-2 md:space-y-4">
          <!-- Gas and MEV Savings Info -->
          <div class="grid grid-cols-2 gap-4 text-sm">
            <div>
              {$t('swap.estimate-gas')}: <span class="font-bold">{displayEstimatedGas ?? '?'}</span>
            </div>
            {#if useSmartAccount && parseFloat(mevSavings) > 0}
              <div class="text-success">
                MEV Savings: <span class="font-bold">${mevSavings}</span>
              </div>
            {/if}
          </div>
          
          <button disabled={!canTrade} class="btn btn-primary btn-md w-full relative md:btn-lg" on:click={trade}>
            {#if trading}
              <Loading text={useSmartAccount ? 'Creating Intent...' : $t('swap.trading')} size="sm" layout="row" />
            {:else if useSmartAccount}
              Create Protected Swap Intent
            {:else}
              {$t('swap.trade')}
            {/if}
          </button>
          
          {#if useSmartAccount}
            <div class="text-xs text-center text-base-content/60">
              Your swap will be bundled with others for MEV protection
            </div>
          {/if}
        </div>
      </div>
    </div>
  </div>

  <!-- Bundle Tracker -->
  {#if useSmartAccount}
    <BundleTracker />
  {/if}
</div>

<!-- MEV Dashboard Modal -->
<MEVDashboard bind:visible={showMEVDashboard} />

<style lang="postcss">
  .Swap {
    @apply w-full rounded-none md:rounded-2xl md:shadow-xl md:w-[600px] dark:bg-black;
  }
</style>